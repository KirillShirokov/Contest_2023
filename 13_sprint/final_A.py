'''
Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере. Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время. Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные исходной отсортированной последовательности. Теперь массив не является отсортированным. Тем не менее, нужно обеспечить возможность находить в нем элемент за 
O
(
log
n
)
.
Можно предполагать, что в массиве только уникальные элементы.
Задачу необходимо сдавать с компилятором Make, он выбран по умолчанию, других компиляторов в задаче нет. Решение отправляется файлом. Требуемые сигнатуры функций лежат в заготовках кода на диске.

От вас требуется реализовать функцию, осуществляющую поиск в сломанном массиве. Файлы с заготовками кода, содержащими сигнатуры функций и базовый тест для поддерживаемых языков, находятся на Яндекс.Диске по ссылке. Обратите внимание, что считывать данные и выводить ответ не требуется.
Расширение файла должно соответствовать языку, на котором вы пишете (.cpp, .java, .go, .js, .py). Если вы пишете на Java, назовите файл с решением Solution.java, для C# – Solution.cs. Для остальных языков название может быть любым, кроме solution.ext, где ext – разрешение для вашего языка.

Формат ввода
Функция принимает массив натуральных чисел и искомое число 
k
. Длина массива не превосходит 
1
0
0
0
0
. Элементы массива и число 
k
 не превосходят по значению 
1
0
0
0
0
.
В примерах:
В первой строке записано число 
n
 –— длина массива.
Во второй строке записано положительное число 
k
 –— искомый элемент. 
Далее в строку через пробел записано 
n
 натуральных чисел – элементы массива.

Формат вывода
Функция должна вернуть индекс элемента, равного 
k
, если такой есть в массиве (нумерация с нуля). Если элемент не найден, функция должна вернуть 
−
1
.
Изменять массив нельзя.
Для отсечения неэффективных решений ваша функция будет запускаться от 
1
0
0
0
0
0
 до 
1
0
0
0
0
0
0
 раз.
'''
# ID 89269781

def broken_search(arr, target) -> int:
    false_find = -1
    first = 0
    last = len(arr) - 1
    while first <= last:
        mid = (first + last) // 2
        if arr[mid] == target:
            return mid
        elif arr[first] <= arr[mid]:
            if arr[first] <= target < arr[mid]:
                last = mid - 1
            else:
                first =  mid + 1
        else:
            if arr[mid] < target <= arr[last]:
                first = mid + 1
            else:
                last = mid - 1
    return false_find


if __name__ == '__main__':
    len_array = int(input())
    find_num = int(input())
    num_array = [int(num) for num in input().split()]
    print(broken_search(num_array, find_num))

